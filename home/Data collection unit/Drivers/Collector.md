# Collector Driver

This document details the `Collector` component, a crucial orchestrator in the system's data acquisition and logging. It manages the flow from data acquisition by `Driver`s to processed data output for logging and transmission.

---
<!-- TOC -->
* [1. Core Components](#1-core-components)
  * [1.1 `Collector` Class: The Orchestrator](#11-collector-class-the-orchestrator)
  * [1.2 IProcess Interface: The Data Decoder](#12-iprocess-interface-the-data-decoder)
* [2. System Overview & Data Identifiers](#2-system-overview--data-identifiers)
  * [2.1 Overall System Structure](#21-overall-system-structure)
  * [2.2 Data Identifiers Sent by Collector](#22-data-identifiers-sent-by-collector)
* [3. Data Flow & Processing Logic](#3-data-flow--processing-logic)
  * [3.1 Collector::update() Function - Detailed Execution](#31-collectorupdate-function---detailed-execution)
  * [3.2 Output Formatting & Protocol](#32-output-formatting--protocol)
  * [3.3 Example Output](#33-example-output)
* [4. Configuration-Driven Behavior](#4-configuration-driven-behavior)
* [Contact](#contact)
<!-- TOC -->

---
## 1. Core Components

### 1.1 `Collector` Class: The Orchestrator

The `Collector` class is the central hub that coordinates data processing and output. It holds lists of `IProcess` and `ILoggable` objects, acting as their execution manager.

**Public Methods:**

*   `Collector()`: Default constructor.
*   `~Collector()`: Default destructor.
*   `void RegisterProcess(IProcess *p)`: Adds a pointer to an IProcess implementation to an internal array (`process[]`). IProcess objects are responsible for transforming raw data into decoded, structured data.
*   `void RegisterData(ILoggable *l)`: Adds a pointer to an ILoggable implementation to an internal array (`loggable[]`). ILoggable objects represent the processed data structures that can be converted into a string for logging/transmission.
*   `void update()`: The main execution method, called periodically, which triggers data processing and output.

### 1.2 IProcess Interface: The Data Decoder

The `IProcess` interface (`IProcess.hpp`) defines a standardized system for processing raw data pulled in by low-level `Driver`s.

**Diagram:**


```
             Driver                 Process                 Collector

           +--------+             +---------+             +-----------+
           |        |             |         |             |           |
           |        |             |         |             |           |
           |        +------------→|         +------------→|           |
           |        |             |         |             |           |
           |        |             |         |             |           |
           +--------+             +---------+             +-----------+

```


## 2. System Overview & Data Identifiers

This section provides an overview of the data flow within the SMART system and identifies the specific types of data that the `Collector` is configured to output.

### 2.1 Overall System Structure

The following diagram illustrates the various data sources and their path through processing units before being managed by the `Collector`.

**Collector diagram**: [Click here to view diagram](https://gitlab.com/hydromotive/2425-acquistionmodule-dev/-/wikis/Drivers/Collector/Diagram)


### 2.2 Data Identifiers Sent by Collector

The Collector concatenates and logs/transmits processed data. Each distinct type of data is typically identified by a unique prefix or ID within the output string generated by its ILoggable::toString() method. The following IDs are expected to be sent by the system:

   *  ACC: Accelerometer data.
   *  SPC: Spectronik fuel cell data.
   *  MPW: Motor Power data.
   *  MTL: Motor Telemetry data.
   *  THR: Throttle position.

## 3. Data Flow & Processing Logic

The `Collector::update()` method orchestrates the entire data pipeline.

### 3.1 Collector::update() Function - Detailed Execution

The `update()` method operates in two distinct phases:

**Phase 1: Triggering Data Processing**

1.  **Iteration:** The Collector loops through its internal `process` array.
2.  **Process Invocation:** For each registered IProcess object (`proc`), it calls `proc->update()`.
    *   At this point, each IProcess implementation performs its specific task: checking for raw data, decoding it, and populating its associated ILoggable object (typically accessible via its `Data` member).
    *   If data is successfully updated, the IProcess sets the `ILoggable::valid` flag of that `ILoggable` object to `true`.

**Phase 2: Conditional Data Output**

1.  **Iteration:** After all IProcess objects have executed, the Collector then iterates through its `loggable` array.
2.  **Validity Check:** For each ILoggable object (`log`), it checks the `log->valid` flag using `log->isValid()`.
3.  **Data Extraction & Buffering (if `log->valid` is `true`):**
    *   The sample timestamp string is retrieved via `log->getSampletimeString()`.
    *   The formatted data string is retrieved via `log->toString()`.
    *   These strings are copied into two dedicated buffers:
        *   `ESPbuffer`: Used for UART transmission to an external module (e.g., ESP32).
        *   `LOGbuffer`: Used for local logging (e.g., to an SD card).
4.  **Protocol Framing (for `ESPbuffer`):**
    *   `ESPbuffer[0]` is set to `Config::GNSS::START_BYTE`.
    *   A 16-bit CRC checksum (`crc::calculateCRC16`) is calculated over the payload (data + timestamp) in `ESPbuffer`.
    *   The CRC is appended to `ESPbuffer` (high byte then low byte).
    *   `Config::GNSS::STOP_BYTE` is appended to `ESPbuffer`.
5.  **Transmission & Logging:**
    *   `HAL_UART_Transmit_DMA(&ESP_Uart, ESPbuffer, ESPindex)` transmits the prepared packet via DMA.
    *   `logger.logData(LOGbuffer, LOGindex)` writes the data to the local logger.
6.  **Flag Reset:** After successful output, `log->valid` is explicitly reset to `false`.
7.  **Buffer Reset:** The `ESPindex` and `LOGindex` pointers are reset to `1` and `0`.

### 3.2 Output Formatting & Protocol

The Collector constructs two types of output messages:

*   **UART Transmission (`ESPbuffer`):**
    *   Used for communication with an external module (e.g., ESP32 for telemetry).
    *   Format: `[START_BYTE][Timestamp][Data][CRC_HIGH][CRC_LOW][STOP_BYTE]`
    *   `START_BYTE` and `STOP_BYTE` are defined in `Config::GNSS`.
    *   A 16-bit CRC (`crc::calculateCRC16`) is applied for data integrity.

*   **Local Logging (`LOGbuffer`):**
    *   Used for storing data locally (e.g., SD card) or debugging.
    *   Format: `[Timestamp][Data]\n`
    *   A newline character `\n` terminates each log entry.


### 3.3 Example Output

Assume an `ILoggable` object generates `getSampletimeString()` as `"23:17:42,099"` and `toString()` as `"ACC,-109,32,-229"`.

**Example `ESPbuffer` Content (conceptual, values are illustrative):**

```c++
Byte Stream: 0x01 '2' '3' ':' '1' '7' ':' '4' '2' ',' '0' '9' '9' | 'A' 'C' 'C' ',' '-' '1' '0' '9' ',' '3' '2' ',' '-' '2' '2' '9' 0x12 0x34 0x18
Interpretation: [START] [ Timestamp String ] [ Data String ] [CRC_H] [CRC_L] [STOP]
```

*Where `0x01` is `Config::GNSS::START_BYTE` and `0x18` is `Config::GNSS::STOP_BYTE`.*

**Example `LOGbuffer` Content:**

```c++
23:17:42,099,ACC,-109,32,-229\n
```

## 4. Configuration-Driven Behavior

The `Collector`'s behavior is influenced by compile-time constants defined in `Config/Config.hpp` under the `Config::collector` and `Config::GNSS` namespaces.

*   `Config::collector::buffer_size`: Defines the maximum size of the `ESPbuffer` and `LOGbuffer`. This directly impacts the maximum length of a single loggable data string.
*   `Config::GNSS::START_BYTE`: Specifies the start delimiter byte for UART transmissions.
*   `Config::GNSS::STOP_BYTE`: Specifies the stop delimiter byte for UART transmissions.
*   `DATA_SOURCE_COUNT`: A `constexpr` in `collector.hpp` that limits the maximum number of `IProcess` and `ILoggable` objects that can be registered.

---
## Contact
sjoerd 